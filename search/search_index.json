{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Guigaga","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install guigaga\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Simply decorate your script with the <code>@gui()</code> decorator to add a GUI to your click CLI.</p> <pre><code>import click\nfrom guigaga import gui\n\n\n@gui()\n@click.command()\n@click.argument(\"sequence\",  type=str)\ndef reverse_complement(sequence):\n    \"\"\"This script computes the reverse complement of a DNA sequence.\"\"\"\n    complement = {\"A\": \"T\", \"T\": \"A\", \"C\": \"G\", \"G\": \"C\", \"N\": \"N\"}\n    sequence = sequence.upper()\n    result = \"\".join(complement[base] for base in reversed(sequence))\n    click.echo(result)\n\nif __name__ == \"__main__\":\n    reverse_complement()\n</code></pre> <p>Run the script with the <code>gui</code> argument to open the gradio powered GUI:</p> <pre><code>$ python app.py gui\n</code></pre> <p></p> <p>Add it still works as a command line script: <pre><code>$ python app.py reverse_complement ATGC\nGCAT\n</code></pre></p> <p>Check out the live demo here or colab.</p>"},{"location":"#license","title":"License","text":"<p><code>guigaga</code> is distributed under the terms of the MIT license and was heavily inspired by trogon.</p>"},{"location":"#_1","title":"Home","text":"<p>All We Need Is GUI Ga Ga!</p>"},{"location":"reference/decorator/","title":"Decorator","text":""},{"location":"reference/decorator/#src.guigaga.decorator.gui","title":"<code>gui(name=None, command_name='gui', message='Launch the GUI.', *, theme='soft', hide_not_required=False, allow_file_download=False, launch_kwargs=None, queue_kwargs=None, catch_errors=True)</code>","text":"<p>Creates a decorator for a click command or group to add a GUI interface.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the application. Defaults to None.</p> <code>None</code> <code>command_name</code> <code>str</code> <p>The name of the command to open the GUI. Defaults to \"gui\".</p> <code>'gui'</code> <code>message</code> <code>str</code> <p>The message to display when the GUI is opened. Defaults to \"Open Gradio GUI.\"</p> <code>'Launch the GUI.'</code> <code>theme</code> <code>GradioTheme | str</code> <p>The theme to use for the GUI. Defaults to Soft.</p> <code>'soft'</code> <code>hide_not_required</code> <code>bool</code> <p>Whether to hide options that are not required. Defaults to False.</p> <code>False</code> <code>allow_file_download</code> <code>bool</code> <p>Whether to allow file downloads. Defaults to False.</p> <code>False</code> <code>launch_kwargs</code> <code>Optional[dict]</code> <p>Additional keyword arguments to pass to the launch method. Defaults to None.</p> <code>None</code> <code>queue_kwargs</code> <code>Optional[dict]</code> <p>Additional keyword arguments to pass to the queue method. Defaults to None.</p> <code>None</code> <code>catch_errors</code> <code>bool</code> <p>Whether to catch and display errors in the GUI. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>A decorator that can be used to add a GUI to a click command or group.</p> Source code in <code>src/guigaga/decorator.py</code> <pre><code>def gui(\n    name: Optional[str] = None,\n    command_name: str = \"gui\",\n    message: str = \"Launch the GUI.\",\n    *,\n    theme: str = \"soft\",\n    hide_not_required: bool = False,\n    allow_file_download: bool = False,\n    launch_kwargs: Optional[dict] = None,\n    queue_kwargs: Optional[dict] = None,\n    catch_errors: bool = True,\n) -&gt; Callable:\n    \"\"\"\n    Creates a decorator for a click command or group to add a GUI interface.\n\n    Args:\n      name (Optional[str]): The name of the application. Defaults to None.\n      command_name (str): The name of the command to open the GUI. Defaults to \"gui\".\n      message (str): The message to display when the GUI is opened. Defaults to \"Open Gradio GUI.\"\n      theme (GradioTheme|str): The theme to use for the GUI. Defaults to Soft.\n      hide_not_required (bool): Whether to hide options that are not required. Defaults to False.\n      allow_file_download (bool): Whether to allow file downloads. Defaults to False.\n      launch_kwargs (Optional[dict]): Additional keyword arguments to pass to the launch method. Defaults to None.\n      queue_kwargs (Optional[dict]): Additional keyword arguments to pass to the queue method. Defaults to None.\n      catch_errors (bool): Whether to catch and display errors in the GUI. Defaults to True.\n\n    Returns:\n      Callable: A decorator that can be used to add a GUI to a click command or group.\n    \"\"\"\n    if launch_kwargs is None:\n        launch_kwargs = {}\n    if queue_kwargs is None:\n        queue_kwargs = {}\n\n    def decorator(app):\n        \"\"\"\n        A decorator that adds a GUI to a click command or group.\n\n        Args:\n            app (Union[click.Group, click.Command]): The click command or group to add the GUI to.\n\n        Returns:\n            Union[click.Group, click.Command]: The click command or group with the added GUI.\n        \"\"\"\n        import click\n\n\n        @click.pass_context\n        @click.option(\n            \"--share\",\n            is_flag=True,\n            default=False,\n            required=False,\n            help=\"Share the GUI over the internet.\"\n        )\n        @click.option(\n            \"--host\",\n            type=str,\n            default=\"127.0.0.1\",\n            required=False,\n            help=\"Host address to use for sharing the GUI.\"\n        )\n        @click.option(\n            \"--port\",\n            type=int,\n            default=7860,\n            required=False,\n            help=\"Port number to use for sharing the GUI.\"\n        )\n        def wrapped_gui(ctx, share, host, port):  # noqa: ARG001\n            \"\"\"\n            A click command that launches the GUI.\n\n            Args:\n                ctx (click.Context): The click context.\n                share (bool): Whether to share the GUI over the internet.\n                host (str): The host address to use for sharing the GUI.\n                port (int): The port number to use for sharing the GUI.\n\n            Side Effects:\n                Modifies the launch_kwargs dictionary based on the CLI inputs.\n                Launches the GUI.\n\n            Notes:\n                This function is decorated with click.pass_context, and click.option for \"share\", \"host\", and \"port\".\n            \"\"\"\n            from guigaga.guigaga import GUIGAGA\n\n            # Mapping of CLI option names to launch_kwargs keys\n            cli_mappings = {\n                \"share\": \"share\",\n                \"host\": \"server_name\",\n                \"port\": \"server_port\",\n            }\n\n            # Update launch_kwargs based on CLI inputs\n            update_launch_kwargs_from_cli(ctx, launch_kwargs, cli_mappings)\n\n            # Build the interface using GUIGAGA\n            GUIGAGA(\n                app,\n                app_name=name,\n                command_name=command_name,\n                click_context=click.get_current_context(),\n                theme=theme,\n                hide_not_required=hide_not_required,\n                allow_file_download=allow_file_download,\n                catch_errors=catch_errors,\n            ).launch(queue_kwargs=queue_kwargs, launch_kwargs=launch_kwargs)\n\n        # Handle case where app is a click.Group or a click.Command\n        if isinstance(app, click.Group):\n            app.command(name=command_name, help=message)(wrapped_gui)\n        else:\n            new_group = click.Group()\n            new_group.add_command(app)\n            new_group.command(name=command_name, help=message)(wrapped_gui)\n            return new_group\n\n        return app\n\n    return decorator\n</code></pre>"},{"location":"reference/decorator/#src.guigaga.decorator.update_launch_kwargs_from_cli","title":"<code>update_launch_kwargs_from_cli(ctx, launch_kwargs, cli_mappings)</code>","text":"<p>Update launch_kwargs with CLI options that differ from their defaults.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <p>Click context object containing the command parameters and options.</p> required <code>launch_kwargs</code> <p>Dictionary to update with CLI-specified values.</p> required <code>cli_mappings</code> <p>Dictionary mapping CLI option names to their corresponding launch_kwargs keys.</p> required Source code in <code>src/guigaga/decorator.py</code> <pre><code>def update_launch_kwargs_from_cli(ctx, launch_kwargs, cli_mappings):\n    \"\"\"\n    Update launch_kwargs with CLI options that differ from their defaults.\n\n    Args:\n        ctx: Click context object containing the command parameters and options.\n        launch_kwargs: Dictionary to update with CLI-specified values.\n        cli_mappings: Dictionary mapping CLI option names to their corresponding launch_kwargs keys.\n    \"\"\"\n    for param in ctx.command.params:\n        param_name = param.name\n        if param_name in cli_mappings and ctx.params[param_name] != param.default:\n            launch_kwargs[cli_mappings[param_name]] = ctx.params[param_name]\n</code></pre>"},{"location":"reference/guigaga/","title":"Guigaga","text":""},{"location":"reference/guigaga/#src.guigaga.guigaga.GUIGAGA","title":"<code>GUIGAGA</code>","text":"<p>A class to build a graphical user interface for a given command line interface.</p> Source code in <code>src/guigaga/guigaga.py</code> <pre><code>class GUIGAGA:\n    \"\"\"\n    A class to build a graphical user interface for a given command line interface.\n    \"\"\"\n    def __init__(\n        self,\n        cli: click.Group | click.Command,\n        app_name: str | None = None,\n        command_name: str = \"gui\",\n        click_context: click.Context = None,\n        *,\n        theme: GradioTheme | str = \"soft\",\n        hide_not_required: bool = False,\n        allow_file_download: bool = False,\n        catch_errors: bool = True,\n    ):\n        \"\"\"\n        Initializes the GUIGAGA with the given parameters.\n\n        Args:\n          cli (click.Group | click.Command): The command line interface to build a GUI for.\n          app_name (str | None): The name of the application. Defaults to None.\n          command_name (str): The name of the command. Defaults to \"gui\".\n          click_context (click.Context): The context of the click command. Defaults to None.\n          theme (GradioTheme): The theme of the GUI. Defaults to Soft.\n          hide_not_required (bool): Whether to hide not required options. Defaults to False.\n          allow_file_download (bool): Whether to allow file download. Defaults to False.\n          catch_errors (bool): Whether to catch errors. Defaults to True.\n\n        Side Effects:\n          - Initializes various instance variables.\n          - Calls introspect_click_app to get the command schemas.\n          - Calls traverse_command_tree to create the interface.\n        \"\"\"\n        self.cli = cli\n        self.app_name = app_name if app_name else self.cli.name.upper()\n        self.command_name = command_name\n        self.theme = theme\n        self.hide_not_required = hide_not_required\n        self.allow_file_download = allow_file_download\n        self.catch_errors = catch_errors\n        self.command_schemas = introspect_click_app(cli)\n        self.blocks = []\n        self.click_context = click_context\n        try:\n            self.version = metadata.version(self.click_app_name)\n        except Exception:\n            self.version = None\n        # Traverse the command tree and create the interface\n        if isinstance(self.command_schemas, dict) and \"root\" in self.command_schemas:\n            schema_tree = self.command_schemas[\"root\"]\n        else:\n            schema_tree = next(iter(self.command_schemas.values()))\n        self.interface = self.traverse_command_tree(schema_tree)\n\n    def launch(self, queue_kwargs: Optional[dict] = None, launch_kwargs: Optional[dict] = None):\n        \"\"\"\n        Launches the GUI.\n\n        Args:\n          **kwargs: Additional keyword arguments to pass to the launch method.\n\n        Side Effects:\n          - Launches the GUI.\n        \"\"\"\n        if launch_kwargs is None:\n            launch_kwargs = {}\n        if queue_kwargs is None:\n            queue_kwargs = {}\n        self.interface.queue(**queue_kwargs).launch(**launch_kwargs)\n\n    def traverse_command_tree(self, schema: CommandSchema):\n        \"\"\"Recursively traverse the command tree and create a tabbed interface for each nested command group\"\"\"\n        tab_blocks = []\n        # If the current schema has no subcommands, create a block\n        if not schema.subcommands:\n            block = self.create_block(schema)\n            tab_blocks.append(block)\n        else:\n            # Process all subcommands of the current schema\n            for subcommand in schema.subcommands.values():\n                if subcommand.name == self.command_name:\n                    continue\n                # Recursively traverse subcommands and collect blocks\n                if subcommand.subcommands:  # Check if it's a group with nested commands\n                    sub_interface = self.traverse_command_tree(subcommand)\n                    tab_blocks.append((subcommand.name, sub_interface))\n                else:\n                    block = self.create_block(subcommand)\n                    tab_blocks.append(block)\n\n        # If there are multiple blocks, create a TabbedInterface\n        if len(tab_blocks) &gt; 1:\n            tab_names = [name for name, _ in tab_blocks]\n            interface_list = [block for _, block in tab_blocks]\n            if schema.name == \"root\":\n                with gr.Blocks(theme=self.theme, analytics_enabled=False, title=self.app_name) as block:\n                    version = f\" (v{self.version})\" if self.version else \"\"\n                    gr.Markdown(f\"\"\"# {self.app_name}{version}\\n{schema.docstring}\"\"\")\n                    # gr.Markdown(f\"{schema.docstring}\")\n                    TabbedInterface(interface_list, tab_names=tab_names, analytics_enabled=False)\n                return block\n            return TabbedInterface(interface_list, tab_names=tab_names, analytics_enabled=False)\n        # If there's only one block, just return that block (no tabs needed)\n        elif len(tab_blocks) == 1:\n            return tab_blocks[0][1]\n        msg = \"Could not create interface for command schema.\"\n        raise ValueError(msg)\n\n\n    def create_block(self, command_schema: CommandSchema):\n        \"\"\"\n        Creates a block for the given command schema.\n\n        Args:\n          command_schema (CommandSchema): The command schema to create a block for.\n\n        Returns:\n          tuple: The name of the command and the created block.\n\n        Side Effects:\n          - Creates various GUI components.\n          - Defines the run_command function.\n        \"\"\"\n        logger = Logger()\n        with Blocks(theme=self.theme, analytics_enabled=False, title=self.app_name) as block:\n            self.render_help_and_header(command_schema)\n            with gr.Row():\n                with gr.Column():\n                    if self.hide_not_required:\n                        schemas = self.render_schemas(command_schema, render_not_required=False)\n                        if self.has_advanced_options(command_schema):\n                            with gr.Accordion(\"Advanced Options\", open=False):\n                                schemas.update(self.render_schemas(command_schema, render_required=False))\n                    else:\n                        schemas = self.render_schemas(command_schema)\n                with gr.Column():\n                    btn = gr.Button(\"Run\")\n                    with gr.Tab(\"Logs\"):\n                        logs = gr.Textbox(show_label=False, lines=19, max_lines=19)\n                    with gr.Tab(\"Output\", visible=False) as output_tab:\n                        outputs = self.get_outputs(command_schema)\n                    if self.allow_file_download:\n                        with gr.Tab(\"Files\"):\n                            file_explorer = gr.FileExplorer(\n                                label=\"Choose a file to download\",\n                                file_count=\"single\",\n                                every=1,\n                                height=400,\n                            )\n                            output_file = gr.File(\n                                label=\"Download file\",\n                                inputs=file_explorer,\n                                visible=False,\n                            )\n\n                            def update(filename):\n                                return gr.File(filename, visible=True)\n\n                            file_explorer.change(update, file_explorer, output_file)\n\n            # Define the run_command function as a generator\n            def run_command(*args, **kwargs):\n                # Start the logger's wrapped function which is a generator\n                def unwrap(function):\n                    if hasattr(function, \"__wrapped__\"):\n                        return unwrap(function.__wrapped__)\n                    return function\n                function = unwrap(command_schema.function)\n                log_gen = logger.intercept_stdin_stdout(\n                    function, self.click_context, catch_errors=self.catch_errors\n                )(*args, **kwargs)\n                logs_output = \"\"\n                # For each yielded log output\n                for log_chunk in log_gen:\n                    logs_output += log_chunk\n                    # Yield logs and no update for other outputs\n                    if self.allow_file_download:\n                        yield [logs_output, gr.Tab(\"Output\", visible=False), None]\n                    else:\n                        yield [logs_output, gr.Tab(\"Output\", visible=False)]\n                if logger.exit_code:\n                    if self.allow_file_download:\n                        return [logs_output, gr.Tab(\"Output\", visible=False), None]\n                    return [logs_output, gr.Tab(\"Output\", visible=False)]\n                # After function completes, yield final outputs\n                # Update output_group visibility and outputs\n                render_outputs = False\n                if outputs:\n                    render_outputs = True\n                yield [logs_output, gr.Tab(\"Output\", visible=render_outputs), *self.get_output_values(command_schema)]\n\n            inputs = self.sort_schemas(command_schema, schemas)\n            btn.click(fn=run_command, inputs=inputs, outputs=[logs, output_tab, *outputs])\n        return command_schema.name, block\n\n    def get_outputs(self, command_schema: CommandSchema):\n        \"\"\"\n        Gets the outputs for the given command schema.\n\n        Args:\n          command_schema (CommandSchema): The command schema to get the outputs for.\n\n        Returns:\n          list: The list of outputs.\n        \"\"\"\n        outputs = []\n        for schema in command_schema.options + command_schema.arguments:\n            if isinstance(schema.type, OutputParamType):\n                outputs.append(schema.type.render(schema))\n        return outputs\n\n    def get_output_values(self, command_schema: CommandSchema):\n        \"\"\"\n        Gets the output values for the given command schema.\n\n        Args:\n          command_schema (CommandSchema): The command schema to get the output values for.\n\n        Returns:\n          list: The list of output values.\n        \"\"\"\n        outputs = []\n        for schema in command_schema.options + command_schema.arguments:\n            if isinstance(schema.type, OutputParamType):\n                outputs.append(schema.type.value)\n        return outputs\n\n    def render_help_and_header(self, command_schema: CommandSchema):\n        \"\"\"\n        Renders the help and header for the given command schema.\n\n        Args:\n          command_schema (CommandSchema): The command schema to render the help and header for.\n\n        Side Effects:\n          - Renders the help and header.\n        \"\"\"\n        gr.Markdown(f\"\"\"# {command_schema.name}\"\"\")\n        gr.Markdown(command_schema.docstring)\n\n    def has_advanced_options(self, command_schema: CommandSchema):\n        \"\"\"\n        Checks if the given command schema has advanced options.\n\n        Args:\n          command_schema (CommandSchema): The command schema to check.\n\n        Returns:\n          bool: True if the command schema has advanced options, False otherwise.\n        \"\"\"\n        return any(not schema.required for schema in command_schema.options + command_schema.arguments)\n\n    def render_schemas(self, command_schema, *, render_required=True, render_not_required=True):\n        \"\"\"\n        Renders the schemas for the given command schema.\n\n        Args:\n          command_schema (CommandSchema): The command schema to render the schemas for.\n          render_required (bool): Whether to render required schemas. Defaults to True.\n          render_not_required (bool): Whether to render not required schemas. Defaults to True.\n\n        Returns:\n          dict: The rendered schemas.\n        \"\"\"\n        inputs = {}\n        schemas = command_schema.arguments + command_schema.options  #TODO: sort the schemas before passing them to the render function\n        schemas = [\n            schema\n            for schema in schemas\n            if (render_required and schema.required) or (render_not_required and not schema.required)\n        ]\n        schemas_name_map = {\n            schema.name if isinstance(schema.name, str) else schema.name[0].lstrip(\"-\").replace(\"-\", \"_\"): schema for schema in schemas\n        }\n        for name, schema in schemas_name_map.items():\n            component = self.get_component(schema)\n            inputs[name] = component\n        return inputs\n\n    def sort_schemas(self, command_schema, schemas: dict):\n        \"\"\"\n        Sorts the given schemas based on the order of the command schema's function arguments.\n\n        Args:\n          command_schema (CommandSchema): The command schema to sort the schemas based on.\n          schemas (dict): The schemas to sort.\n\n        Returns:\n          list: The sorted schemas.\n        \"\"\"\n        # recursively unwrap the function\n        def unwrap(function):\n            if hasattr(function, \"__wrapped__\"):\n                return unwrap(function.__wrapped__)\n            return function\n        function = unwrap(command_schema.function)\n        order = function.__code__.co_varnames[: function.__code__.co_argcount]\n        schemas = [schemas[name] for name in order if name in schemas]\n        return schemas\n\n    def get_component(self, schema: OptionSchema | ArgumentSchema):\n        \"\"\"\n        Gets the component for the given schema.\n\n        Args:\n          schema (OptionSchema | ArgumentSchema): The schema to get the component for.\n\n        Returns:\n          gradio.Interface: The component for the given schema.\n        \"\"\"\n\n        default = None\n        if schema.default.values:\n            default = schema.default.values[0][0]\n        if isinstance(schema, OptionSchema):\n            label = schema.name[0].lstrip(\"-\")\n            help_text = schema.help\n        else:\n            label = schema.name\n            help_text = None\n        # Handle different component types\n        if isinstance(schema.type, OutputParamType):\n            return gr.Textbox(value=schema.type.value, visible=False)\n        if isinstance(schema.type, InputParamType):\n            return schema.type.render(schema)\n        # Defaults will be moved into Types\n        component_type_name = schema.type.name\n        if component_type_name == \"text\":\n            return gr.Textbox(label=label, value=default, info=help_text)\n\n        elif component_type_name == \"integer\":\n            return gr.Number(default, label=label, precision=0, info=help_text)\n\n        elif component_type_name == \"float\":\n            return gr.Number(default, label=label, info=help_text)\n\n        elif component_type_name == \"boolean\":\n            return gr.Checkbox(default == \"true\", label=label, info=help_text)\n\n        elif component_type_name == \"uuid\":\n            uuid_val = str(uuid.uuid4()) if default is None else default\n            return gr.Textbox(uuid_val, label=label, info=help_text)\n\n        elif component_type_name == \"filename\":\n            return gr.File(label=label, value=default)\n\n        elif component_type_name == \"path\":\n            return gr.File(label=label, value=default)\n\n        elif component_type_name == \"choice\":\n            choices = schema.type.choices\n            return gr.Dropdown(choices, value=default, label=label, info=help_text)\n\n        elif component_type_name == \"integer range\":\n            min_val = schema.type.min if schema.type.min is not None else 0\n            max_val = schema.type.max if schema.type.max is not None else 100\n            return gr.Slider(minimum=min_val, maximum=max_val, step=1, value=default, label=label, info=help_text)\n\n        elif component_type_name == \"float range\":\n            min_val = schema.type.min if schema.type.min is not None else 0.0\n            max_val = schema.type.max if schema.type.max is not None else 1.0\n            return gr.Slider(minimum=min_val, maximum=max_val, value=default, label=label, step=0.01, info=help_text)\n\n        elif component_type_name == \"datetime\":\n            formats = (\n                schema.type.formats if schema.type.formats else [\"%Y-%m-%d\", \"%Y-%m-%dT%H:%M:%S\", \"%Y-%m-%d %H:%M:%S\"]\n            )\n            datetime_val = default if default is not None else datetime.now().strftime(formats[0])  # noqa: DTZ005\n            return gr.DateTime(value=datetime_val, label=label, info=help_text)\n\n        else:\n            return gr.Textbox(value=default, label=label, info=help_text)\n</code></pre>"},{"location":"reference/guigaga/#src.guigaga.guigaga.GUIGAGA.__init__","title":"<code>__init__(cli, app_name=None, command_name='gui', click_context=None, *, theme='soft', hide_not_required=False, allow_file_download=False, catch_errors=True)</code>","text":"<p>Initializes the GUIGAGA with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>cli</code> <code>click.Group | click.Command</code> <p>The command line interface to build a GUI for.</p> required <code>app_name</code> <code>str | None</code> <p>The name of the application. Defaults to None.</p> <code>None</code> <code>command_name</code> <code>str</code> <p>The name of the command. Defaults to \"gui\".</p> <code>'gui'</code> <code>click_context</code> <code>click.Context</code> <p>The context of the click command. Defaults to None.</p> <code>None</code> <code>theme</code> <code>GradioTheme</code> <p>The theme of the GUI. Defaults to Soft.</p> <code>'soft'</code> <code>hide_not_required</code> <code>bool</code> <p>Whether to hide not required options. Defaults to False.</p> <code>False</code> <code>allow_file_download</code> <code>bool</code> <p>Whether to allow file download. Defaults to False.</p> <code>False</code> <code>catch_errors</code> <code>bool</code> <p>Whether to catch errors. Defaults to True.</p> <code>True</code> Side Effects <ul> <li>Initializes various instance variables.</li> <li>Calls introspect_click_app to get the command schemas.</li> <li>Calls traverse_command_tree to create the interface.</li> </ul> Source code in <code>src/guigaga/guigaga.py</code> <pre><code>def __init__(\n    self,\n    cli: click.Group | click.Command,\n    app_name: str | None = None,\n    command_name: str = \"gui\",\n    click_context: click.Context = None,\n    *,\n    theme: GradioTheme | str = \"soft\",\n    hide_not_required: bool = False,\n    allow_file_download: bool = False,\n    catch_errors: bool = True,\n):\n    \"\"\"\n    Initializes the GUIGAGA with the given parameters.\n\n    Args:\n      cli (click.Group | click.Command): The command line interface to build a GUI for.\n      app_name (str | None): The name of the application. Defaults to None.\n      command_name (str): The name of the command. Defaults to \"gui\".\n      click_context (click.Context): The context of the click command. Defaults to None.\n      theme (GradioTheme): The theme of the GUI. Defaults to Soft.\n      hide_not_required (bool): Whether to hide not required options. Defaults to False.\n      allow_file_download (bool): Whether to allow file download. Defaults to False.\n      catch_errors (bool): Whether to catch errors. Defaults to True.\n\n    Side Effects:\n      - Initializes various instance variables.\n      - Calls introspect_click_app to get the command schemas.\n      - Calls traverse_command_tree to create the interface.\n    \"\"\"\n    self.cli = cli\n    self.app_name = app_name if app_name else self.cli.name.upper()\n    self.command_name = command_name\n    self.theme = theme\n    self.hide_not_required = hide_not_required\n    self.allow_file_download = allow_file_download\n    self.catch_errors = catch_errors\n    self.command_schemas = introspect_click_app(cli)\n    self.blocks = []\n    self.click_context = click_context\n    try:\n        self.version = metadata.version(self.click_app_name)\n    except Exception:\n        self.version = None\n    # Traverse the command tree and create the interface\n    if isinstance(self.command_schemas, dict) and \"root\" in self.command_schemas:\n        schema_tree = self.command_schemas[\"root\"]\n    else:\n        schema_tree = next(iter(self.command_schemas.values()))\n    self.interface = self.traverse_command_tree(schema_tree)\n</code></pre>"},{"location":"reference/guigaga/#src.guigaga.guigaga.GUIGAGA.create_block","title":"<code>create_block(command_schema)</code>","text":"<p>Creates a block for the given command schema.</p> <p>Parameters:</p> Name Type Description Default <code>command_schema</code> <code>CommandSchema</code> <p>The command schema to create a block for.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>The name of the command and the created block.</p> Side Effects <ul> <li>Creates various GUI components.</li> <li>Defines the run_command function.</li> </ul> Source code in <code>src/guigaga/guigaga.py</code> <pre><code>def create_block(self, command_schema: CommandSchema):\n    \"\"\"\n    Creates a block for the given command schema.\n\n    Args:\n      command_schema (CommandSchema): The command schema to create a block for.\n\n    Returns:\n      tuple: The name of the command and the created block.\n\n    Side Effects:\n      - Creates various GUI components.\n      - Defines the run_command function.\n    \"\"\"\n    logger = Logger()\n    with Blocks(theme=self.theme, analytics_enabled=False, title=self.app_name) as block:\n        self.render_help_and_header(command_schema)\n        with gr.Row():\n            with gr.Column():\n                if self.hide_not_required:\n                    schemas = self.render_schemas(command_schema, render_not_required=False)\n                    if self.has_advanced_options(command_schema):\n                        with gr.Accordion(\"Advanced Options\", open=False):\n                            schemas.update(self.render_schemas(command_schema, render_required=False))\n                else:\n                    schemas = self.render_schemas(command_schema)\n            with gr.Column():\n                btn = gr.Button(\"Run\")\n                with gr.Tab(\"Logs\"):\n                    logs = gr.Textbox(show_label=False, lines=19, max_lines=19)\n                with gr.Tab(\"Output\", visible=False) as output_tab:\n                    outputs = self.get_outputs(command_schema)\n                if self.allow_file_download:\n                    with gr.Tab(\"Files\"):\n                        file_explorer = gr.FileExplorer(\n                            label=\"Choose a file to download\",\n                            file_count=\"single\",\n                            every=1,\n                            height=400,\n                        )\n                        output_file = gr.File(\n                            label=\"Download file\",\n                            inputs=file_explorer,\n                            visible=False,\n                        )\n\n                        def update(filename):\n                            return gr.File(filename, visible=True)\n\n                        file_explorer.change(update, file_explorer, output_file)\n\n        # Define the run_command function as a generator\n        def run_command(*args, **kwargs):\n            # Start the logger's wrapped function which is a generator\n            def unwrap(function):\n                if hasattr(function, \"__wrapped__\"):\n                    return unwrap(function.__wrapped__)\n                return function\n            function = unwrap(command_schema.function)\n            log_gen = logger.intercept_stdin_stdout(\n                function, self.click_context, catch_errors=self.catch_errors\n            )(*args, **kwargs)\n            logs_output = \"\"\n            # For each yielded log output\n            for log_chunk in log_gen:\n                logs_output += log_chunk\n                # Yield logs and no update for other outputs\n                if self.allow_file_download:\n                    yield [logs_output, gr.Tab(\"Output\", visible=False), None]\n                else:\n                    yield [logs_output, gr.Tab(\"Output\", visible=False)]\n            if logger.exit_code:\n                if self.allow_file_download:\n                    return [logs_output, gr.Tab(\"Output\", visible=False), None]\n                return [logs_output, gr.Tab(\"Output\", visible=False)]\n            # After function completes, yield final outputs\n            # Update output_group visibility and outputs\n            render_outputs = False\n            if outputs:\n                render_outputs = True\n            yield [logs_output, gr.Tab(\"Output\", visible=render_outputs), *self.get_output_values(command_schema)]\n\n        inputs = self.sort_schemas(command_schema, schemas)\n        btn.click(fn=run_command, inputs=inputs, outputs=[logs, output_tab, *outputs])\n    return command_schema.name, block\n</code></pre>"},{"location":"reference/guigaga/#src.guigaga.guigaga.GUIGAGA.get_component","title":"<code>get_component(schema)</code>","text":"<p>Gets the component for the given schema.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>OptionSchema | ArgumentSchema</code> <p>The schema to get the component for.</p> required <p>Returns:</p> Type Description <p>gradio.Interface: The component for the given schema.</p> Source code in <code>src/guigaga/guigaga.py</code> <pre><code>def get_component(self, schema: OptionSchema | ArgumentSchema):\n    \"\"\"\n    Gets the component for the given schema.\n\n    Args:\n      schema (OptionSchema | ArgumentSchema): The schema to get the component for.\n\n    Returns:\n      gradio.Interface: The component for the given schema.\n    \"\"\"\n\n    default = None\n    if schema.default.values:\n        default = schema.default.values[0][0]\n    if isinstance(schema, OptionSchema):\n        label = schema.name[0].lstrip(\"-\")\n        help_text = schema.help\n    else:\n        label = schema.name\n        help_text = None\n    # Handle different component types\n    if isinstance(schema.type, OutputParamType):\n        return gr.Textbox(value=schema.type.value, visible=False)\n    if isinstance(schema.type, InputParamType):\n        return schema.type.render(schema)\n    # Defaults will be moved into Types\n    component_type_name = schema.type.name\n    if component_type_name == \"text\":\n        return gr.Textbox(label=label, value=default, info=help_text)\n\n    elif component_type_name == \"integer\":\n        return gr.Number(default, label=label, precision=0, info=help_text)\n\n    elif component_type_name == \"float\":\n        return gr.Number(default, label=label, info=help_text)\n\n    elif component_type_name == \"boolean\":\n        return gr.Checkbox(default == \"true\", label=label, info=help_text)\n\n    elif component_type_name == \"uuid\":\n        uuid_val = str(uuid.uuid4()) if default is None else default\n        return gr.Textbox(uuid_val, label=label, info=help_text)\n\n    elif component_type_name == \"filename\":\n        return gr.File(label=label, value=default)\n\n    elif component_type_name == \"path\":\n        return gr.File(label=label, value=default)\n\n    elif component_type_name == \"choice\":\n        choices = schema.type.choices\n        return gr.Dropdown(choices, value=default, label=label, info=help_text)\n\n    elif component_type_name == \"integer range\":\n        min_val = schema.type.min if schema.type.min is not None else 0\n        max_val = schema.type.max if schema.type.max is not None else 100\n        return gr.Slider(minimum=min_val, maximum=max_val, step=1, value=default, label=label, info=help_text)\n\n    elif component_type_name == \"float range\":\n        min_val = schema.type.min if schema.type.min is not None else 0.0\n        max_val = schema.type.max if schema.type.max is not None else 1.0\n        return gr.Slider(minimum=min_val, maximum=max_val, value=default, label=label, step=0.01, info=help_text)\n\n    elif component_type_name == \"datetime\":\n        formats = (\n            schema.type.formats if schema.type.formats else [\"%Y-%m-%d\", \"%Y-%m-%dT%H:%M:%S\", \"%Y-%m-%d %H:%M:%S\"]\n        )\n        datetime_val = default if default is not None else datetime.now().strftime(formats[0])  # noqa: DTZ005\n        return gr.DateTime(value=datetime_val, label=label, info=help_text)\n\n    else:\n        return gr.Textbox(value=default, label=label, info=help_text)\n</code></pre>"},{"location":"reference/guigaga/#src.guigaga.guigaga.GUIGAGA.get_output_values","title":"<code>get_output_values(command_schema)</code>","text":"<p>Gets the output values for the given command schema.</p> <p>Parameters:</p> Name Type Description Default <code>command_schema</code> <code>CommandSchema</code> <p>The command schema to get the output values for.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>The list of output values.</p> Source code in <code>src/guigaga/guigaga.py</code> <pre><code>def get_output_values(self, command_schema: CommandSchema):\n    \"\"\"\n    Gets the output values for the given command schema.\n\n    Args:\n      command_schema (CommandSchema): The command schema to get the output values for.\n\n    Returns:\n      list: The list of output values.\n    \"\"\"\n    outputs = []\n    for schema in command_schema.options + command_schema.arguments:\n        if isinstance(schema.type, OutputParamType):\n            outputs.append(schema.type.value)\n    return outputs\n</code></pre>"},{"location":"reference/guigaga/#src.guigaga.guigaga.GUIGAGA.get_outputs","title":"<code>get_outputs(command_schema)</code>","text":"<p>Gets the outputs for the given command schema.</p> <p>Parameters:</p> Name Type Description Default <code>command_schema</code> <code>CommandSchema</code> <p>The command schema to get the outputs for.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>The list of outputs.</p> Source code in <code>src/guigaga/guigaga.py</code> <pre><code>def get_outputs(self, command_schema: CommandSchema):\n    \"\"\"\n    Gets the outputs for the given command schema.\n\n    Args:\n      command_schema (CommandSchema): The command schema to get the outputs for.\n\n    Returns:\n      list: The list of outputs.\n    \"\"\"\n    outputs = []\n    for schema in command_schema.options + command_schema.arguments:\n        if isinstance(schema.type, OutputParamType):\n            outputs.append(schema.type.render(schema))\n    return outputs\n</code></pre>"},{"location":"reference/guigaga/#src.guigaga.guigaga.GUIGAGA.has_advanced_options","title":"<code>has_advanced_options(command_schema)</code>","text":"<p>Checks if the given command schema has advanced options.</p> <p>Parameters:</p> Name Type Description Default <code>command_schema</code> <code>CommandSchema</code> <p>The command schema to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the command schema has advanced options, False otherwise.</p> Source code in <code>src/guigaga/guigaga.py</code> <pre><code>def has_advanced_options(self, command_schema: CommandSchema):\n    \"\"\"\n    Checks if the given command schema has advanced options.\n\n    Args:\n      command_schema (CommandSchema): The command schema to check.\n\n    Returns:\n      bool: True if the command schema has advanced options, False otherwise.\n    \"\"\"\n    return any(not schema.required for schema in command_schema.options + command_schema.arguments)\n</code></pre>"},{"location":"reference/guigaga/#src.guigaga.guigaga.GUIGAGA.launch","title":"<code>launch(queue_kwargs=None, launch_kwargs=None)</code>","text":"<p>Launches the GUI.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments to pass to the launch method.</p> required Side Effects <ul> <li>Launches the GUI.</li> </ul> Source code in <code>src/guigaga/guigaga.py</code> <pre><code>def launch(self, queue_kwargs: Optional[dict] = None, launch_kwargs: Optional[dict] = None):\n    \"\"\"\n    Launches the GUI.\n\n    Args:\n      **kwargs: Additional keyword arguments to pass to the launch method.\n\n    Side Effects:\n      - Launches the GUI.\n    \"\"\"\n    if launch_kwargs is None:\n        launch_kwargs = {}\n    if queue_kwargs is None:\n        queue_kwargs = {}\n    self.interface.queue(**queue_kwargs).launch(**launch_kwargs)\n</code></pre>"},{"location":"reference/guigaga/#src.guigaga.guigaga.GUIGAGA.render_help_and_header","title":"<code>render_help_and_header(command_schema)</code>","text":"<p>Renders the help and header for the given command schema.</p> <p>Parameters:</p> Name Type Description Default <code>command_schema</code> <code>CommandSchema</code> <p>The command schema to render the help and header for.</p> required Side Effects <ul> <li>Renders the help and header.</li> </ul> Source code in <code>src/guigaga/guigaga.py</code> <pre><code>def render_help_and_header(self, command_schema: CommandSchema):\n    \"\"\"\n    Renders the help and header for the given command schema.\n\n    Args:\n      command_schema (CommandSchema): The command schema to render the help and header for.\n\n    Side Effects:\n      - Renders the help and header.\n    \"\"\"\n    gr.Markdown(f\"\"\"# {command_schema.name}\"\"\")\n    gr.Markdown(command_schema.docstring)\n</code></pre>"},{"location":"reference/guigaga/#src.guigaga.guigaga.GUIGAGA.render_schemas","title":"<code>render_schemas(command_schema, *, render_required=True, render_not_required=True)</code>","text":"<p>Renders the schemas for the given command schema.</p> <p>Parameters:</p> Name Type Description Default <code>command_schema</code> <code>CommandSchema</code> <p>The command schema to render the schemas for.</p> required <code>render_required</code> <code>bool</code> <p>Whether to render required schemas. Defaults to True.</p> <code>True</code> <code>render_not_required</code> <code>bool</code> <p>Whether to render not required schemas. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The rendered schemas.</p> Source code in <code>src/guigaga/guigaga.py</code> <pre><code>def render_schemas(self, command_schema, *, render_required=True, render_not_required=True):\n    \"\"\"\n    Renders the schemas for the given command schema.\n\n    Args:\n      command_schema (CommandSchema): The command schema to render the schemas for.\n      render_required (bool): Whether to render required schemas. Defaults to True.\n      render_not_required (bool): Whether to render not required schemas. Defaults to True.\n\n    Returns:\n      dict: The rendered schemas.\n    \"\"\"\n    inputs = {}\n    schemas = command_schema.arguments + command_schema.options  #TODO: sort the schemas before passing them to the render function\n    schemas = [\n        schema\n        for schema in schemas\n        if (render_required and schema.required) or (render_not_required and not schema.required)\n    ]\n    schemas_name_map = {\n        schema.name if isinstance(schema.name, str) else schema.name[0].lstrip(\"-\").replace(\"-\", \"_\"): schema for schema in schemas\n    }\n    for name, schema in schemas_name_map.items():\n        component = self.get_component(schema)\n        inputs[name] = component\n    return inputs\n</code></pre>"},{"location":"reference/guigaga/#src.guigaga.guigaga.GUIGAGA.sort_schemas","title":"<code>sort_schemas(command_schema, schemas)</code>","text":"<p>Sorts the given schemas based on the order of the command schema's function arguments.</p> <p>Parameters:</p> Name Type Description Default <code>command_schema</code> <code>CommandSchema</code> <p>The command schema to sort the schemas based on.</p> required <code>schemas</code> <code>dict</code> <p>The schemas to sort.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>The sorted schemas.</p> Source code in <code>src/guigaga/guigaga.py</code> <pre><code>def sort_schemas(self, command_schema, schemas: dict):\n    \"\"\"\n    Sorts the given schemas based on the order of the command schema's function arguments.\n\n    Args:\n      command_schema (CommandSchema): The command schema to sort the schemas based on.\n      schemas (dict): The schemas to sort.\n\n    Returns:\n      list: The sorted schemas.\n    \"\"\"\n    # recursively unwrap the function\n    def unwrap(function):\n        if hasattr(function, \"__wrapped__\"):\n            return unwrap(function.__wrapped__)\n        return function\n    function = unwrap(command_schema.function)\n    order = function.__code__.co_varnames[: function.__code__.co_argcount]\n    schemas = [schemas[name] for name in order if name in schemas]\n    return schemas\n</code></pre>"},{"location":"reference/guigaga/#src.guigaga.guigaga.GUIGAGA.traverse_command_tree","title":"<code>traverse_command_tree(schema)</code>","text":"<p>Recursively traverse the command tree and create a tabbed interface for each nested command group</p> Source code in <code>src/guigaga/guigaga.py</code> <pre><code>def traverse_command_tree(self, schema: CommandSchema):\n    \"\"\"Recursively traverse the command tree and create a tabbed interface for each nested command group\"\"\"\n    tab_blocks = []\n    # If the current schema has no subcommands, create a block\n    if not schema.subcommands:\n        block = self.create_block(schema)\n        tab_blocks.append(block)\n    else:\n        # Process all subcommands of the current schema\n        for subcommand in schema.subcommands.values():\n            if subcommand.name == self.command_name:\n                continue\n            # Recursively traverse subcommands and collect blocks\n            if subcommand.subcommands:  # Check if it's a group with nested commands\n                sub_interface = self.traverse_command_tree(subcommand)\n                tab_blocks.append((subcommand.name, sub_interface))\n            else:\n                block = self.create_block(subcommand)\n                tab_blocks.append(block)\n\n    # If there are multiple blocks, create a TabbedInterface\n    if len(tab_blocks) &gt; 1:\n        tab_names = [name for name, _ in tab_blocks]\n        interface_list = [block for _, block in tab_blocks]\n        if schema.name == \"root\":\n            with gr.Blocks(theme=self.theme, analytics_enabled=False, title=self.app_name) as block:\n                version = f\" (v{self.version})\" if self.version else \"\"\n                gr.Markdown(f\"\"\"# {self.app_name}{version}\\n{schema.docstring}\"\"\")\n                # gr.Markdown(f\"{schema.docstring}\")\n                TabbedInterface(interface_list, tab_names=tab_names, analytics_enabled=False)\n            return block\n        return TabbedInterface(interface_list, tab_names=tab_names, analytics_enabled=False)\n    # If there's only one block, just return that block (no tabs needed)\n    elif len(tab_blocks) == 1:\n        return tab_blocks[0][1]\n    msg = \"Could not create interface for command schema.\"\n    raise ValueError(msg)\n</code></pre>"},{"location":"reference/introspect/","title":"Introspect","text":""},{"location":"reference/introspect/#src.guigaga.introspect.ArgumentSchema","title":"<code>ArgumentSchema</code>  <code>dataclass</code>","text":"<p>A data class for defining the schema of a CLI argument.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the argument.</p> <code>type</code> <code>str</code> <p>The type of the argument.</p> <code>required</code> <code>bool</code> <p>Whether the argument is required.</p> <code>key</code> <code>str</code> <p>The key for the argument.</p> <code>default</code> <code>MultiValueParamData | None</code> <p>The default value of the argument.</p> <code>choices</code> <code>Sequence[str] | None</code> <p>The choices for the argument.</p> <code>multiple</code> <code>bool</code> <p>Whether the argument can have multiple values.</p> <code>nargs</code> <code>int</code> <p>The number of arguments for the argument.</p> Source code in <code>src/guigaga/introspect.py</code> <pre><code>@dataclass\nclass ArgumentSchema:\n    \"\"\"\n    A data class for defining the schema of a CLI argument.\n\n    Attributes:\n      name (str): The name of the argument.\n      type (str): The type of the argument.\n      required (bool): Whether the argument is required.\n      key (str): The key for the argument.\n      default (MultiValueParamData | None): The default value of the argument.\n      choices (Sequence[str] | None): The choices for the argument.\n      multiple (bool): Whether the argument can have multiple values.\n      nargs (int): The number of arguments for the argument.\n    \"\"\"\n    name: str\n    type: str\n    required: bool = False\n    key: str = field(default_factory=generate_unique_id)\n    default: MultiValueParamData | None = None\n    choices: Sequence[str] | None = None\n    multiple: bool = False\n    nargs: int = 1\n</code></pre>"},{"location":"reference/introspect/#src.guigaga.introspect.CommandSchema","title":"<code>CommandSchema</code>  <code>dataclass</code>","text":"<p>A data class for defining the schema of a CLI command.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>CommandName</code> <p>The name of the command.</p> <code>function</code> <code>Callable[..., Any | None]</code> <p>The function to execute when the command is called.</p> <code>key</code> <code>str</code> <p>The key for the command.</p> <code>docstring</code> <code>str | None</code> <p>The docstring for the command.</p> <code>options</code> <code>list[OptionSchema]</code> <p>The options for the command.</p> <code>arguments</code> <code>list[ArgumentSchema]</code> <p>The arguments for the command.</p> <code>subcommands</code> <code>dict['CommandName', 'CommandSchema']</code> <p>The subcommands for the command.</p> <code>parent</code> <code>CommandSchema | None</code> <p>The parent command.</p> <code>is_group</code> <code>bool</code> <p>Whether the command is a group command.</p> Source code in <code>src/guigaga/introspect.py</code> <pre><code>@dataclass\nclass CommandSchema:\n    \"\"\"\n    A data class for defining the schema of a CLI command.\n\n    Attributes:\n      name (CommandName): The name of the command.\n      function (Callable[..., Any | None]): The function to execute when the command is called.\n      key (str): The key for the command.\n      docstring (str | None): The docstring for the command.\n      options (list[OptionSchema]): The options for the command.\n      arguments (list[ArgumentSchema]): The arguments for the command.\n      subcommands (dict[\"CommandName\", \"CommandSchema\"]): The subcommands for the command.\n      parent (CommandSchema | None): The parent command.\n      is_group (bool): Whether the command is a group command.\n    \"\"\"\n    name: CommandName\n    function: Callable[..., Any | None]\n    key: str = field(default_factory=generate_unique_id)\n    docstring: str | None = None\n    options: list[OptionSchema] = field(default_factory=list)\n    arguments: list[ArgumentSchema] = field(default_factory=list)\n    subcommands: dict[\"CommandName\", \"CommandSchema\"] = field(default_factory=dict)\n    parent: \"CommandSchema | None\" = None\n    is_group: bool = False\n\n    @property\n    def path_from_root(self) -&gt; list[\"CommandSchema\"]:\n        \"\"\"\n        Gets the path from the root command to the current command.\n\n        Returns:\n          list[CommandSchema]: A list of CommandSchema instances representing the path from the root command to the current command.\n        \"\"\"\n        node = self\n        path = [self]\n        while True:\n            node = node.parent\n            if node is None:\n                break\n            path.append(node)\n        return list(reversed(path))\n</code></pre>"},{"location":"reference/introspect/#src.guigaga.introspect.CommandSchema.path_from_root","title":"<code>path_from_root: list['CommandSchema']</code>  <code>property</code>","text":"<p>Gets the path from the root command to the current command.</p> <p>Returns:</p> Type Description <code>list['CommandSchema']</code> <p>list[CommandSchema]: A list of CommandSchema instances representing the path from the root command to the current command.</p>"},{"location":"reference/introspect/#src.guigaga.introspect.MultiValueParamData","title":"<code>MultiValueParamData</code>  <code>dataclass</code>","text":"<p>A data class for storing multiple values from a command line interface (CLI) option.</p> <p>Attributes:</p> Name Type Description <code>values</code> <code>list[tuple[int | float | str]]</code> <p>A list of tuples containing the values.</p> Source code in <code>src/guigaga/introspect.py</code> <pre><code>@dataclass\nclass MultiValueParamData:\n    \"\"\"\n    A data class for storing multiple values from a command line interface (CLI) option.\n\n    Attributes:\n      values (list[tuple[int | float | str]]): A list of tuples containing the values.\n    \"\"\"\n    values: list[tuple[int | float | str]]\n\n    @staticmethod\n    def process_cli_option(value) -&gt; \"MultiValueParamData\":\n        \"\"\"\n        Processes a CLI option value into a MultiValueParamData instance.\n\n        Args:\n          value (Any): The value to process.\n\n        Returns:\n          MultiValueParamData: A MultiValueParamData instance containing the processed value.\n\n        Examples:\n          &gt;&gt;&gt; MultiValueParamData.process_cli_option(('a', 'b', 'c'))\n          MultiValueParamData(values=[('a', 'b', 'c')])\n        \"\"\"\n        if value is None:\n            value = MultiValueParamData([])\n        elif isinstance(value, tuple):\n            value = MultiValueParamData([value])\n        elif isinstance(value, list):\n            processed_list = [\n                (item,) if not isinstance(item, tuple) else item for item in value\n            ]\n            value = MultiValueParamData(processed_list)\n        else:\n            value = MultiValueParamData([(value,)])\n\n        return value\n</code></pre>"},{"location":"reference/introspect/#src.guigaga.introspect.MultiValueParamData.process_cli_option","title":"<code>process_cli_option(value)</code>  <code>staticmethod</code>","text":"<p>Processes a CLI option value into a MultiValueParamData instance.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to process.</p> required <p>Returns:</p> Name Type Description <code>MultiValueParamData</code> <code>'MultiValueParamData'</code> <p>A MultiValueParamData instance containing the processed value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MultiValueParamData.process_cli_option(('a', 'b', 'c'))\nMultiValueParamData(values=[('a', 'b', 'c')])\n</code></pre> Source code in <code>src/guigaga/introspect.py</code> <pre><code>@staticmethod\ndef process_cli_option(value) -&gt; \"MultiValueParamData\":\n    \"\"\"\n    Processes a CLI option value into a MultiValueParamData instance.\n\n    Args:\n      value (Any): The value to process.\n\n    Returns:\n      MultiValueParamData: A MultiValueParamData instance containing the processed value.\n\n    Examples:\n      &gt;&gt;&gt; MultiValueParamData.process_cli_option(('a', 'b', 'c'))\n      MultiValueParamData(values=[('a', 'b', 'c')])\n    \"\"\"\n    if value is None:\n        value = MultiValueParamData([])\n    elif isinstance(value, tuple):\n        value = MultiValueParamData([value])\n    elif isinstance(value, list):\n        processed_list = [\n            (item,) if not isinstance(item, tuple) else item for item in value\n        ]\n        value = MultiValueParamData(processed_list)\n    else:\n        value = MultiValueParamData([(value,)])\n\n    return value\n</code></pre>"},{"location":"reference/introspect/#src.guigaga.introspect.OptionSchema","title":"<code>OptionSchema</code>  <code>dataclass</code>","text":"<p>A data class for defining the schema of a CLI option.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>list[str]</code> <p>The names of the option.</p> <code>type</code> <code>ParamType</code> <p>The type of the option.</p> <code>default</code> <code>MultiValueParamData | None</code> <p>The default value of the option.</p> <code>required</code> <code>bool</code> <p>Whether the option is required.</p> <code>is_flag</code> <code>bool</code> <p>Whether the option is a flag.</p> <code>is_boolean_flag</code> <code>bool</code> <p>Whether the option is a boolean flag.</p> <code>flag_value</code> <code>Any</code> <p>The value of the flag.</p> <code>opts</code> <code>list</code> <p>Additional options.</p> <code>counting</code> <code>bool</code> <p>Whether the option is counting.</p> <code>secondary_opts</code> <code>list</code> <p>Secondary options.</p> <code>key</code> <code>str | tuple[str]</code> <p>The key for the option.</p> <code>help</code> <code>str | None</code> <p>The help text for the option.</p> <code>choices</code> <code>Sequence[str] | None</code> <p>The choices for the option.</p> <code>multiple</code> <code>bool</code> <p>Whether the option can have multiple values.</p> <code>multi_value</code> <code>bool</code> <p>Whether the option is a multi-value option.</p> <code>nargs</code> <code>int</code> <p>The number of arguments for the option.</p> Source code in <code>src/guigaga/introspect.py</code> <pre><code>@dataclass\nclass OptionSchema:\n    \"\"\"\n    A data class for defining the schema of a CLI option.\n\n    Attributes:\n      name (list[str]): The names of the option.\n      type (ParamType): The type of the option.\n      default (MultiValueParamData | None): The default value of the option.\n      required (bool): Whether the option is required.\n      is_flag (bool): Whether the option is a flag.\n      is_boolean_flag (bool): Whether the option is a boolean flag.\n      flag_value (Any): The value of the flag.\n      opts (list): Additional options.\n      counting (bool): Whether the option is counting.\n      secondary_opts (list): Secondary options.\n      key (str | tuple[str]): The key for the option.\n      help (str | None): The help text for the option.\n      choices (Sequence[str] | None): The choices for the option.\n      multiple (bool): Whether the option can have multiple values.\n      multi_value (bool): Whether the option is a multi-value option.\n      nargs (int): The number of arguments for the option.\n    \"\"\"\n    name: list[str]\n    type: ParamType\n    default: MultiValueParamData | None = None\n    required: bool = False\n    is_flag: bool = False\n    is_boolean_flag: bool = False\n    flag_value: Any = \"\"\n    opts: list = field(default_factory=list)\n    counting: bool = False\n    secondary_opts: list = field(default_factory=list)\n    key: str | tuple[str] = field(default_factory=generate_unique_id)\n    help: str | None = None\n    choices: Sequence[str] | None = None\n    multiple: bool = False\n    multi_value: bool = False\n    nargs: int = 1\n\n    def __post_init__(self):\n        \"\"\"\n        Post-initialization method for OptionSchema. Sets the multi_value attribute based on the type attribute.\n        \"\"\"\n        self.multi_value = isinstance(self.type, click.Tuple)\n</code></pre>"},{"location":"reference/introspect/#src.guigaga.introspect.OptionSchema.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-initialization method for OptionSchema. Sets the multi_value attribute based on the type attribute.</p> Source code in <code>src/guigaga/introspect.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Post-initialization method for OptionSchema. Sets the multi_value attribute based on the type attribute.\n    \"\"\"\n    self.multi_value = isinstance(self.type, click.Tuple)\n</code></pre>"},{"location":"reference/introspect/#src.guigaga.introspect.generate_unique_id","title":"<code>generate_unique_id()</code>","text":"<p>Generates a unique identifier.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>A unique identifier string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; generate_unique_id()\n'id_1234abcd'\n</code></pre> Source code in <code>src/guigaga/introspect.py</code> <pre><code>def generate_unique_id():\n    \"\"\"\n    Generates a unique identifier.\n\n    Returns:\n      str: A unique identifier string.\n\n    Examples:\n      &gt;&gt;&gt; generate_unique_id()\n      'id_1234abcd'\n    \"\"\"\n    return f\"id_{str(uuid.uuid4())[:8]}\"\n</code></pre>"},{"location":"reference/introspect/#src.guigaga.introspect.introspect_click_app","title":"<code>introspect_click_app(app)</code>","text":"<p>Introspect a Click application and build a data structure containing information about all commands, options, arguments, and subcommands, including the docstrings and command function references.</p> <p>This function recursively processes each command and its subcommands (if any), creating a nested dictionary that includes details about options, arguments, and subcommands, as well as the docstrings and command function references.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>click.BaseCommand</code> <p>The Click application's top-level group or command instance.</p> required <p>Returns:</p> Type Description <code>dict[CommandName, CommandSchema]</code> <p>Dict[str, CommandData]: A nested dictionary containing the Click application's</p> <code>dict[CommandName, CommandSchema]</code> <p>structure. The structure is defined by the CommandData TypedDict and its related</p> <code>dict[CommandName, CommandSchema]</code> <p>TypedDicts (OptionData and ArgumentData).</p> Source code in <code>src/guigaga/introspect.py</code> <pre><code>def introspect_click_app(app: BaseCommand) -&gt; dict[CommandName, CommandSchema]:\n    \"\"\"\n    Introspect a Click application and build a data structure containing\n    information about all commands, options, arguments, and subcommands,\n    including the docstrings and command function references.\n\n    This function recursively processes each command and its subcommands\n    (if any), creating a nested dictionary that includes details about\n    options, arguments, and subcommands, as well as the docstrings and\n    command function references.\n\n    Args:\n        app (click.BaseCommand): The Click application's top-level group or command instance.\n\n    Returns:\n        Dict[str, CommandData]: A nested dictionary containing the Click application's\n        structure. The structure is defined by the CommandData TypedDict and its related\n        TypedDicts (OptionData and ArgumentData).\n    \"\"\"\n\n    def process_command(\n        cmd_name: CommandName, cmd_obj: click.Command, parent=None\n    ) -&gt; CommandSchema:\n        cmd_data = CommandSchema(\n            name=cmd_name,\n            docstring=cmd_obj.help,\n            function=cmd_obj.callback,\n            options=[],\n            arguments=[],\n            subcommands={},\n            parent=parent,\n            is_group=isinstance(cmd_obj, click.Group),\n        )\n\n        for param in cmd_obj.params:\n            default = MultiValueParamData.process_cli_option(param.default)\n            if isinstance(param, (click.Option, click.core.Group)):\n                option_data = OptionSchema(\n                    name=param.opts,\n                    type=param.type,\n                    is_flag=param.is_flag,\n                    is_boolean_flag=param.is_bool_flag,\n                    flag_value=param.flag_value,\n                    counting=param.count,\n                    opts=param.opts,\n                    secondary_opts=param.secondary_opts,\n                    required=param.required,\n                    default=default,\n                    help=param.help,\n                    multiple=param.multiple,\n                    nargs=param.nargs,\n                )\n                if isinstance(param.type, click.Choice):\n                    option_data.choices = param.type.choices\n                cmd_data.options.append(option_data)\n            elif isinstance(param, click.Argument):\n                argument_data = ArgumentSchema(\n                    name=param.name,\n                    type=param.type,\n                    required=param.required,\n                    multiple=param.multiple,\n                    default=default,\n                    nargs=param.nargs,\n                )\n                if isinstance(param.type, click.Choice):\n                    argument_data.choices = param.type.choices\n                cmd_data.arguments.append(argument_data)\n\n        if isinstance(cmd_obj, click.core.Group):\n            for subcmd_name, subcmd_obj in cmd_obj.commands.items():\n                cmd_data.subcommands[CommandName(subcmd_name)] = process_command(\n                    CommandName(subcmd_name), subcmd_obj, parent=cmd_data\n                )\n\n        return cmd_data\n\n    data: dict[CommandName, CommandSchema] = {}\n\n    # Special case for the root group\n    if isinstance(app, click.Group):\n        root_cmd_name = CommandName(\"root\")\n        data[root_cmd_name] = process_command(root_cmd_name, app)\n        app = data[root_cmd_name]\n\n    if isinstance(app, click.Group):\n        for cmd_name, cmd_obj in app.commands.items():\n            data[CommandName(cmd_name)] = process_command(\n                CommandName(cmd_name), cmd_obj\n            )\n    elif isinstance(app, click.Command):\n        cmd_name = CommandName(app.name)\n        data[cmd_name] = process_command(cmd_name, app)\n\n    return data\n</code></pre>"},{"location":"reference/logger/","title":"Logger","text":""},{"location":"reference/logger/#src.guigaga.logger.CapturingStream","title":"<code>CapturingStream</code>","text":"<p>             Bases: <code>io.StringIO</code></p> <p>Stream to capture stdout/stderr line by line and put them in a queue.</p> Source code in <code>src/guigaga/logger.py</code> <pre><code>class CapturingStream(io.StringIO):\n    \"\"\"Stream to capture stdout/stderr line by line and put them in a queue.\"\"\"\n    def __init__(self, queue: mpQueue, *args, **kwargs):\n        \"\"\"\n        Initializes a new instance of the CapturingStream class.\n\n        Args:\n          queue (mpQueue): The queue to put the captured lines in.\n          *args: Variable length argument list.\n          **kwargs: Arbitrary keyword arguments.\n\n        Side Effects:\n          Initializes the _queue attribute with the provided queue and the _current_line attribute to an empty string.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._queue = queue\n        self._current_line = \"\"\n\n    def write(self, s: str) -&gt; int:\n        \"\"\"\n        Writes a string to the stream and captures it line by line.\n\n        Args:\n          s (str): The string to write.\n\n        Returns:\n          int: The number of characters written.\n\n        Side Effects:\n          Writes the string to the stream and captures it line by line, putting each line in the queue.\n\n        Notes:\n          Normalizes newlines by replacing \"\\r\" with \"\\\\n\".\n        \"\"\"\n        s = s.replace(\"\\r\", \"\\n\")  # Normalize newlines\n        if \"\\n\" in s:\n            lines = s.split(\"\\n\")\n            for line in lines[:-1]:\n                self._current_line += line\n                self._queue.put(self._current_line)\n                self._current_line = \"\"\n            self._current_line += lines[-1]\n        else:\n            self._current_line += s\n        return super().write(s)\n\n    def flush(self):\n        \"\"\"\n        Flushes the stream and captures the current line.\n\n        Side Effects:\n          If there is a current line, puts it in the queue and resets the current line to an empty string. Then flushes the stream.\n        \"\"\"\n        if self._current_line:\n            self._queue.put(self._current_line)\n            self._current_line = \"\"\n        super().flush()\n</code></pre>"},{"location":"reference/logger/#src.guigaga.logger.CapturingStream.__init__","title":"<code>__init__(queue, *args, **kwargs)</code>","text":"<p>Initializes a new instance of the CapturingStream class.</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <code>mpQueue</code> <p>The queue to put the captured lines in.</p> required <code>*args</code> <p>Variable length argument list.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> Side Effects <p>Initializes the _queue attribute with the provided queue and the _current_line attribute to an empty string.</p> Source code in <code>src/guigaga/logger.py</code> <pre><code>def __init__(self, queue: mpQueue, *args, **kwargs):\n    \"\"\"\n    Initializes a new instance of the CapturingStream class.\n\n    Args:\n      queue (mpQueue): The queue to put the captured lines in.\n      *args: Variable length argument list.\n      **kwargs: Arbitrary keyword arguments.\n\n    Side Effects:\n      Initializes the _queue attribute with the provided queue and the _current_line attribute to an empty string.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._queue = queue\n    self._current_line = \"\"\n</code></pre>"},{"location":"reference/logger/#src.guigaga.logger.CapturingStream.flush","title":"<code>flush()</code>","text":"<p>Flushes the stream and captures the current line.</p> Side Effects <p>If there is a current line, puts it in the queue and resets the current line to an empty string. Then flushes the stream.</p> Source code in <code>src/guigaga/logger.py</code> <pre><code>def flush(self):\n    \"\"\"\n    Flushes the stream and captures the current line.\n\n    Side Effects:\n      If there is a current line, puts it in the queue and resets the current line to an empty string. Then flushes the stream.\n    \"\"\"\n    if self._current_line:\n        self._queue.put(self._current_line)\n        self._current_line = \"\"\n    super().flush()\n</code></pre>"},{"location":"reference/logger/#src.guigaga.logger.CapturingStream.write","title":"<code>write(s)</code>","text":"<p>Writes a string to the stream and captures it line by line.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>The string to write.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of characters written.</p> Side Effects <p>Writes the string to the stream and captures it line by line, putting each line in the queue.</p> Notes <p>Normalizes newlines by replacing \" \" with \"\\n\".</p> Source code in <code>src/guigaga/logger.py</code> <pre><code>def write(self, s: str) -&gt; int:\n    \"\"\"\n    Writes a string to the stream and captures it line by line.\n\n    Args:\n      s (str): The string to write.\n\n    Returns:\n      int: The number of characters written.\n\n    Side Effects:\n      Writes the string to the stream and captures it line by line, putting each line in the queue.\n\n    Notes:\n      Normalizes newlines by replacing \"\\r\" with \"\\\\n\".\n    \"\"\"\n    s = s.replace(\"\\r\", \"\\n\")  # Normalize newlines\n    if \"\\n\" in s:\n        lines = s.split(\"\\n\")\n        for line in lines[:-1]:\n            self._current_line += line\n            self._queue.put(self._current_line)\n            self._current_line = \"\"\n        self._current_line += lines[-1]\n    else:\n        self._current_line += s\n    return super().write(s)\n</code></pre>"},{"location":"reference/logger/#src.guigaga.logger.Logger","title":"<code>Logger</code>","text":"<p>A class for logging messages with different levels.</p> <p>Attributes:</p> Name Type Description <code>process</code> <p>The process that the logger is logging for.</p> <code>exit_code</code> <p>The exit code of the process.</p> Source code in <code>src/guigaga/logger.py</code> <pre><code>class Logger:\n    \"\"\"\n    A class for logging messages with different levels.\n\n    Attributes:\n      process: The process that the logger is logging for.\n      exit_code: The exit code of the process.\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Initializes a new instance of the Logger class.\n\n        Side Effects:\n          Initializes the process and exit_code attributes to None.\n        \"\"\"\n        self.process = None\n        self.exit_code = None\n\n    def log(self, message: str, level: str = \"INFO\"):\n        \"\"\"\n        Logs a message with a specified level.\n\n        Args:\n          message (str): The message to log.\n          level (str, optional): The level of the log. Defaults to \"INFO\".\n\n        Returns:\n          dict: A dictionary containing the message and level.\n\n        Examples:\n          &gt;&gt;&gt; logger = Logger()\n          &gt;&gt;&gt; logger.log(\"Hello, World!\")\n          {\"message\": \"Hello, World!\", \"level\": \"INFO\"}\n        \"\"\"\n        return {\"message\": message, \"level\": level}\n\n    def _log_from_queue(self, log_queue) -&gt; Generator[str, None, None]:\n        \"\"\"Fetch logs from the queue and yield them as strings.\"\"\"\n        try:\n            while True:\n                log = log_queue.get_nowait()\n                yield log\n        except queue.Empty:\n            pass\n\n    def intercept_stdin_stdout(self, fn: Callable, ctx, *, catch_errors) -&gt; Callable:\n        \"\"\"Wrap a function to intercept and yield stdout and stderr using threading.\"\"\"\n\n        def wrapped(*args, **kwargs) -&gt; str:\n            # Pass the context to wrap_for_process\n            stdout_queue, stderr_queue, error_queue, wrapped_fn = wrap_for_process(fn, ctx)\n            thread = threading.Thread(target=wrapped_fn, args=args, kwargs=kwargs)\n\n            # Start the thread\n            thread.start()\n\n            # Collect logs while the thread is running\n            logs = []\n            while thread.is_alive():\n                logs.extend(self._log_from_queue(stdout_queue))\n                logs.extend(self._log_from_queue(stderr_queue))\n                thread.join(timeout=0.1)\n\n                # Yield logs\n                yield \"\\n\".join(logs)\n\n            # After the thread completes, yield any remaining logs\n            logs.extend(self._log_from_queue(stdout_queue))\n            logs.extend(self._log_from_queue(stderr_queue))\n\n            # Check for errors\n            try:\n                error_msg = error_queue.get_nowait()\n                self.exit_code = 1\n                if catch_errors:\n                    logs.append(f\"ERROR: {error_msg}\")\n                else:\n                    raise Exception(error_msg)\n            except queue.Empty:\n                self.exit_code = 0\n\n            # Return all logs as a string\n            yield \"\\n\".join(logs)\n\n        return wrapped\n</code></pre>"},{"location":"reference/logger/#src.guigaga.logger.Logger.__init__","title":"<code>__init__()</code>","text":"<p>Initializes a new instance of the Logger class.</p> Side Effects <p>Initializes the process and exit_code attributes to None.</p> Source code in <code>src/guigaga/logger.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes a new instance of the Logger class.\n\n    Side Effects:\n      Initializes the process and exit_code attributes to None.\n    \"\"\"\n    self.process = None\n    self.exit_code = None\n</code></pre>"},{"location":"reference/logger/#src.guigaga.logger.Logger.intercept_stdin_stdout","title":"<code>intercept_stdin_stdout(fn, ctx, *, catch_errors)</code>","text":"<p>Wrap a function to intercept and yield stdout and stderr using threading.</p> Source code in <code>src/guigaga/logger.py</code> <pre><code>def intercept_stdin_stdout(self, fn: Callable, ctx, *, catch_errors) -&gt; Callable:\n    \"\"\"Wrap a function to intercept and yield stdout and stderr using threading.\"\"\"\n\n    def wrapped(*args, **kwargs) -&gt; str:\n        # Pass the context to wrap_for_process\n        stdout_queue, stderr_queue, error_queue, wrapped_fn = wrap_for_process(fn, ctx)\n        thread = threading.Thread(target=wrapped_fn, args=args, kwargs=kwargs)\n\n        # Start the thread\n        thread.start()\n\n        # Collect logs while the thread is running\n        logs = []\n        while thread.is_alive():\n            logs.extend(self._log_from_queue(stdout_queue))\n            logs.extend(self._log_from_queue(stderr_queue))\n            thread.join(timeout=0.1)\n\n            # Yield logs\n            yield \"\\n\".join(logs)\n\n        # After the thread completes, yield any remaining logs\n        logs.extend(self._log_from_queue(stdout_queue))\n        logs.extend(self._log_from_queue(stderr_queue))\n\n        # Check for errors\n        try:\n            error_msg = error_queue.get_nowait()\n            self.exit_code = 1\n            if catch_errors:\n                logs.append(f\"ERROR: {error_msg}\")\n            else:\n                raise Exception(error_msg)\n        except queue.Empty:\n            self.exit_code = 0\n\n        # Return all logs as a string\n        yield \"\\n\".join(logs)\n\n    return wrapped\n</code></pre>"},{"location":"reference/logger/#src.guigaga.logger.Logger.log","title":"<code>log(message, level='INFO')</code>","text":"<p>Logs a message with a specified level.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to log.</p> required <code>level</code> <code>str</code> <p>The level of the log. Defaults to \"INFO\".</p> <code>'INFO'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the message and level.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; logger = Logger()\n&gt;&gt;&gt; logger.log(\"Hello, World!\")\n{\"message\": \"Hello, World!\", \"level\": \"INFO\"}\n</code></pre> Source code in <code>src/guigaga/logger.py</code> <pre><code>def log(self, message: str, level: str = \"INFO\"):\n    \"\"\"\n    Logs a message with a specified level.\n\n    Args:\n      message (str): The message to log.\n      level (str, optional): The level of the log. Defaults to \"INFO\".\n\n    Returns:\n      dict: A dictionary containing the message and level.\n\n    Examples:\n      &gt;&gt;&gt; logger = Logger()\n      &gt;&gt;&gt; logger.log(\"Hello, World!\")\n      {\"message\": \"Hello, World!\", \"level\": \"INFO\"}\n    \"\"\"\n    return {\"message\": message, \"level\": level}\n</code></pre>"},{"location":"reference/logger/#src.guigaga.logger.wrap_for_process","title":"<code>wrap_for_process(fn, ctx)</code>","text":"<p>Wrap the function to capture stdout, stderr, and errors in real-time.</p> Source code in <code>src/guigaga/logger.py</code> <pre><code>def wrap_for_process(fn: Callable, ctx) -&gt; Callable:\n    \"\"\"Wrap the function to capture stdout, stderr, and errors in real-time.\"\"\"\n    stdout_queue = mpQueue()\n    stderr_queue = mpQueue()\n    error_queue = mpQueue()\n\n    @wraps(fn)\n    def _inner(*args, **kwargs):\n        with redirect_stdout(CapturingStream(stdout_queue)), redirect_stderr(CapturingStream(stderr_queue)):\n            try:\n                if ctx:\n                    # Use the context within the thread\n                    with ctx:\n                        fn(*args, **kwargs)\n                else:\n                    fn(*args, **kwargs)\n            except Exception as error:\n                msg = (\n                    f\"Error in '{fn.__name__}':\\n\" +\n                    \"\\n\".join(\n                        line.strip(\"\\n\")\n                        for line in traceback.format_tb(error.__traceback__)\n                        if line.strip()\n                    ) +\n                    f\"\\n\\n{error!s}\"\n                )\n                error_queue.put(msg)\n\n            # Flush final content from buffers\n            sys.stdout.flush()\n            sys.stderr.flush()\n\n    return stdout_queue, stderr_queue, error_queue, _inner\n</code></pre>"},{"location":"reference/types/","title":"Types","text":""},{"location":"reference/types/#src.guigaga.types.Download","title":"<code>Download</code>","text":"<p>             Bases: <code>OutputParamType</code>, <code>ClickPath</code></p> <p>A class that inherits from OutputParamType and ClickPath. It represents a download parameter type.</p> Source code in <code>src/guigaga/types.py</code> <pre><code>class Download(OutputParamType, ClickPath):\n    \"\"\"\n    A class that inherits from OutputParamType and ClickPath. It represents a download parameter type.\n    \"\"\"\n    def __init__(self, filename, *args, **kwargs):\n        \"\"\"\n        Initializes a Download instance.\n\n        Args:\n          filename: The name of the file to download.\n          *args: Variable length argument list.\n          **kwargs: Arbitrary keyword arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.value = filename\n\n    def render(self, schema: OptionSchema | ArgumentSchema) -&gt; Component:\n        \"\"\"\n        Renders the download component.\n\n        Args:\n          schema (OptionSchema | ArgumentSchema): The schema to render.\n\n        Returns:\n          Component: The rendered component.\n        \"\"\"\n        return File(label=schema.name)\n</code></pre>"},{"location":"reference/types/#src.guigaga.types.Download.__init__","title":"<code>__init__(filename, *args, **kwargs)</code>","text":"<p>Initializes a Download instance.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <p>The name of the file to download.</p> required <code>*args</code> <p>Variable length argument list.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> Source code in <code>src/guigaga/types.py</code> <pre><code>def __init__(self, filename, *args, **kwargs):\n    \"\"\"\n    Initializes a Download instance.\n\n    Args:\n      filename: The name of the file to download.\n      *args: Variable length argument list.\n      **kwargs: Arbitrary keyword arguments.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.value = filename\n</code></pre>"},{"location":"reference/types/#src.guigaga.types.Download.render","title":"<code>render(schema)</code>","text":"<p>Renders the download component.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>OptionSchema | ArgumentSchema</code> <p>The schema to render.</p> required <p>Returns:</p> Name Type Description <code>Component</code> <code>Component</code> <p>The rendered component.</p> Source code in <code>src/guigaga/types.py</code> <pre><code>def render(self, schema: OptionSchema | ArgumentSchema) -&gt; Component:\n    \"\"\"\n    Renders the download component.\n\n    Args:\n      schema (OptionSchema | ArgumentSchema): The schema to render.\n\n    Returns:\n      Component: The rendered component.\n    \"\"\"\n    return File(label=schema.name)\n</code></pre>"},{"location":"reference/types/#src.guigaga.types.FileExplorer","title":"<code>FileExplorer</code>","text":"<p>             Bases: <code>InputParamType</code>, <code>ClickPath</code></p> <p>A class that inherits from InputParamType and ClickPath. It represents a file explorer parameter type.</p> Source code in <code>src/guigaga/types.py</code> <pre><code>class FileExplorer(InputParamType, ClickPath):\n    \"\"\"\n    A class that inherits from InputParamType and ClickPath. It represents a file explorer parameter type.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Initializes a FileExplorer instance.\n\n        Args:\n          *args: Variable length argument list.\n          **kwargs: Arbitrary keyword arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n\n    def render(self, schema: OptionSchema | ArgumentSchema) -&gt; Component:\n        \"\"\"\n        Renders the file explorer component.\n\n        Args:\n          schema (OptionSchema | ArgumentSchema): The schema to render.\n\n        Returns:\n          Component: The rendered component.\n        \"\"\"\n        return GradioFileExplorer(label=schema.name, file_count=\"single\", value=schema.default)\n</code></pre>"},{"location":"reference/types/#src.guigaga.types.FileExplorer.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initializes a FileExplorer instance.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Variable length argument list.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> Source code in <code>src/guigaga/types.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"\n    Initializes a FileExplorer instance.\n\n    Args:\n      *args: Variable length argument list.\n      **kwargs: Arbitrary keyword arguments.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"reference/types/#src.guigaga.types.FileExplorer.render","title":"<code>render(schema)</code>","text":"<p>Renders the file explorer component.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>OptionSchema | ArgumentSchema</code> <p>The schema to render.</p> required <p>Returns:</p> Name Type Description <code>Component</code> <code>Component</code> <p>The rendered component.</p> Source code in <code>src/guigaga/types.py</code> <pre><code>def render(self, schema: OptionSchema | ArgumentSchema) -&gt; Component:\n    \"\"\"\n    Renders the file explorer component.\n\n    Args:\n      schema (OptionSchema | ArgumentSchema): The schema to render.\n\n    Returns:\n      Component: The rendered component.\n    \"\"\"\n    return GradioFileExplorer(label=schema.name, file_count=\"single\", value=schema.default)\n</code></pre>"},{"location":"reference/types/#src.guigaga.types.FilePath","title":"<code>FilePath</code>","text":"<p>             Bases: <code>File</code></p> <p>A class that inherits from File. It represents a file path.</p> Source code in <code>src/guigaga/types.py</code> <pre><code>class FilePath(File):\n    \"\"\"\n    A class that inherits from File. It represents a file path.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Initializes a FilePath instance.\n\n        Args:\n          *args: Variable length argument list.\n          **kwargs: Arbitrary keyword arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n\n    def _process_single_file(self, f) -&gt; pathlib.Path | bytes:\n        \"\"\"\n        Processes a single file.\n\n        Args:\n          f: The file to process.\n\n        Returns:\n          pathlib.Path | bytes: The processed file.\n\n        Raises:\n          ValueError: If the file type is unknown.\n        \"\"\"\n        file_name = f.path\n        if self.type == \"filepath\":\n            file = tempfile.NamedTemporaryFile(delete=False, dir=self.GRADIO_CACHE)\n            file.name = file_name\n            return pathlib.Path(file_name)\n        elif self.type == \"binary\":\n            with open(file_name, \"rb\") as file_data:\n                return file_data.read()\n        else:\n            raise ValueError(\n                \"Unknown type: \"\n                + str(type)\n                + \". Please choose from: 'filepath', 'binary'.\"\n            )\n</code></pre>"},{"location":"reference/types/#src.guigaga.types.FilePath.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initializes a FilePath instance.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Variable length argument list.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> Source code in <code>src/guigaga/types.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"\n    Initializes a FilePath instance.\n\n    Args:\n      *args: Variable length argument list.\n      **kwargs: Arbitrary keyword arguments.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"reference/types/#src.guigaga.types.InputParamType","title":"<code>InputParamType</code>","text":"<p>             Bases: <code>ParamType</code></p> <p>A class that inherits from ParamType. It represents an input parameter type.</p> Source code in <code>src/guigaga/types.py</code> <pre><code>class InputParamType(ParamType):\n    \"\"\"\n    A class that inherits from ParamType. It represents an input parameter type.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/types/#src.guigaga.types.OutputParamType","title":"<code>OutputParamType</code>","text":"<p>             Bases: <code>ParamType</code></p> <p>A class that inherits from ParamType. It represents an output parameter type.</p> Source code in <code>src/guigaga/types.py</code> <pre><code>class OutputParamType(ParamType):\n    \"\"\"\n    A class that inherits from ParamType. It represents an output parameter type.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/types/#src.guigaga.types.ParamType","title":"<code>ParamType</code>","text":"<p>             Bases: <code>ClickParamType</code>, <code>ABC</code></p> <p>An abstract base class that inherits from ClickParamType and ABC. It provides a blueprint for parameter types.</p> Source code in <code>src/guigaga/types.py</code> <pre><code>class ParamType(ClickParamType, ABC):\n    \"\"\"\n    An abstract base class that inherits from ClickParamType and ABC. It provides a blueprint for parameter types.\n    \"\"\"\n    @abstractmethod\n    def render(self, schema: OptionSchema | ArgumentSchema) -&gt; Component:\n        \"\"\"\n        An abstract method that must be implemented by any class that inherits from ParamType.\n\n        Args:\n          schema (OptionSchema | ArgumentSchema): The schema to render.\n\n        Returns:\n          Component: The rendered component.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/types/#src.guigaga.types.ParamType.render","title":"<code>render(schema)</code>  <code>abstractmethod</code>","text":"<p>An abstract method that must be implemented by any class that inherits from ParamType.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>OptionSchema | ArgumentSchema</code> <p>The schema to render.</p> required <p>Returns:</p> Name Type Description <code>Component</code> <code>Component</code> <p>The rendered component.</p> Source code in <code>src/guigaga/types.py</code> <pre><code>@abstractmethod\ndef render(self, schema: OptionSchema | ArgumentSchema) -&gt; Component:\n    \"\"\"\n    An abstract method that must be implemented by any class that inherits from ParamType.\n\n    Args:\n      schema (OptionSchema | ArgumentSchema): The schema to render.\n\n    Returns:\n      Component: The rendered component.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/types/#src.guigaga.types.Upload","title":"<code>Upload</code>","text":"<p>             Bases: <code>InputParamType</code>, <code>ClickPath</code></p> <p>A class that inherits from InputParamType and ClickPath. It represents an upload parameter type.</p> Source code in <code>src/guigaga/types.py</code> <pre><code>class Upload(InputParamType, ClickPath):\n    \"\"\"\n    A class that inherits from InputParamType and ClickPath. It represents an upload parameter type.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Initializes an Upload instance.\n\n        Args:\n          *args: Variable length argument list.\n          **kwargs: Arbitrary keyword arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n\n\n    def render(self, schema: OptionSchema | ArgumentSchema) -&gt; Component:\n        \"\"\"\n        Renders the upload component.\n\n        Args:\n          schema (OptionSchema | ArgumentSchema): The schema to render.\n\n        Returns:\n          Component: The rendered component.\n        \"\"\"\n        return File(label=schema.name)\n</code></pre>"},{"location":"reference/types/#src.guigaga.types.Upload.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initializes an Upload instance.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Variable length argument list.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> Source code in <code>src/guigaga/types.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"\n    Initializes an Upload instance.\n\n    Args:\n      *args: Variable length argument list.\n      **kwargs: Arbitrary keyword arguments.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"reference/types/#src.guigaga.types.Upload.render","title":"<code>render(schema)</code>","text":"<p>Renders the upload component.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>OptionSchema | ArgumentSchema</code> <p>The schema to render.</p> required <p>Returns:</p> Name Type Description <code>Component</code> <code>Component</code> <p>The rendered component.</p> Source code in <code>src/guigaga/types.py</code> <pre><code>def render(self, schema: OptionSchema | ArgumentSchema) -&gt; Component:\n    \"\"\"\n    Renders the upload component.\n\n    Args:\n      schema (OptionSchema | ArgumentSchema): The schema to render.\n\n    Returns:\n      Component: The rendered component.\n    \"\"\"\n    return File(label=schema.name)\n</code></pre>"}]}